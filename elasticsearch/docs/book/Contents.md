# 엘라스틱 서치 실무 가이드

## 검색 시스템 이해하기
- 전체 흐름
    - 검색엔진으로서 엘라스틱 서치의 이해
    - 데이터의 모델링
    - 데이터의 검색 방법과 효율성 제고
    - 데이터를 그룹화하고 통계치를 얻는 집계
    - 엘라스틱 서치의 기반 기술인 루씬
    - 안정된 클러스터 운영

### 1.1 검색시스템의 이해
검색 시스템과 검색엔진의 정의, 검색엔진인 엘라스틱 서치와 데이터베이스의 차이

> 검색 시스템이란?
- 검색엔진이란 광활한 웹에서 정보를 수집해 검색 결과를 제공하는 프로그램
- 검색시스템은 대용량 데이터를 기반으로 신회성있는 검색결과를 제공하기 위해 검색엔진을 기반으로 구축된 시스템을 통칭하는 용어
    - 수집기를 이용한 데이터 수집, 다수의 검색엔진을 이용한 색인, 검색 결과를 UI로 제공
    - 시스템 내부의 정책에 따라 특정 필드나 문서에 가중치를 둔 검색 정확도

> 검색 시스템의 구성 요소

- 정보를 수집하는 수집기
- 수집한 데이터를 저장하는 스토리지
- 수집한 데이터를 검색에 적절한 형태로 변환하는 색인기
- 색인된 데이터에서 일치하는 문서를 찾는 검색기

- 수집기
    - 파일, 데이터베이스, 웹페이지 등 웹 상의 대부분의 정보가 수집대상이다.
    - 파일의 경우 수집기가 파일명, 파일 내용, 파일 경로 등의 정보를 수집하여 저장하면 검색엔진이 저장된 정보를 검색하여 질의에 응답하게 된다.
- 스토리지
    - 데이터베이스에서 데이터를 저장하는 물리적인 저장소
- 색인기
    - 수집된 데이터를 검색 가능한 구조로 가공하고 저장
    - 다양한 형태소 분석기를 조합해 정보에서 의미가 있는 용어를 추출, 검색에 유리한 역색인 구조로 데이터를 저장
- 검색기
    - 사용자의 질의를 입력받아 색인기에서 저장한 역색인 구조에서 일치하는 문서를 찾아 결과로 반환
    - 질의와 문서가 일치하는지는 유사도 기반의 검색 순위 알고리즘으로 판단
    - 검색기 또한 색인기와 마찬가지로 형태소 분석기를 이용해 사용자 질의에서 유의미한 용어를 추출해 검색
        - 사용하는 형태소 분석기에 따라 검색 품질 차이가 발생할 수 있다.

> 관계형 데이터베이스와의 차이점
- 관계형 데이터베이스의 특징
    - 데이터를 통합 관리하는 데이터의 집합
    - 저장 방식에 따라 크게 관계형 또는 계층형 데이터베이스로 구분
    - 모든 데이터베이스는 중복을 제거하고, 정형 데이터로 구조화해 행과 열로 구성된 테이블에 저장
    - SQL 문을 이용해 원하는 정보의 검색이 가능하나 텍스트 매칭을 통한 단순한 검색만 가능
    - 텍스트를 여러 단어로 변형하거나 여러 개의 동의어나 유의어를 활용한 검색은 불가능
- 검색엔진의 특징
    - 비정형 데이터를 색인하고 검색
    - 형태소 분석을 통해 사람이 구사하는 자연어의 처리가 가능
    - 역색인 구조를 바탕으로 빠른 검색 속도를 보장

- 용어 구분

    |엘라스틱서치|관계형 데이터베이스|
    |:---:|:---:|
    |인덱스(Index)|데이터베이스(Database)|
    |샤드(shard)|파티션(partition)|
    |타입(type)|테이블(table)|
    |문서(document)|행(row)|
    |필드(field)|열(column)|
    |매핑(mapping)|스키마(schema)|
    |Query DSL|SQL|
    
    ```text
    * 관계형데이터베이스의 인덱스는 where 절의 쿼리와 join을 빠르게 만드는 보조 데이터 도구로 사용
    * 6.0 이하 버전 하나의 인덱스 내부에 기능에 따라 데이터를 분류하고 여러 개의 타입을 만들어 사용
    * 현재는 하나의 인덱스에 하나의 타입만 구성하도록 변경
    ```

- 요청 방식 차이 

    |기능|엘라스틱서치|데이터베이스|
    |:----:|:----:|:----:|
    |데이터의 조회|GET|SELECT|
    |데이터의 생성|PUT|INSERT|
    |인덱스 업데이트, 데이터 조회|POST|UPDATE, SELECT|
    |데이터 삭제|DELETE|DELETE|
    |인덱스의 정보 확인|HEAD|-|

    ```text
    * RESTful API
    HTTP 헤더(header)와 URL만 사용해 다양한 형태의 요청을 할 수 있는 HTTP 프로토콜을 최대한 활용하도록 고안된 아키텍처
    ```

    - 엘라스틱 서치를 사용하기 위한 간단한 API 요청 구조
    
    ```shell
    curl -X(method) http://host:port/(index)/(type)/(document id) -d '{json data}'
    ```

> 엘라스틱 서치의 API의 기본 문법
    

### 1.2. 검색 시스템과 엘라스틱서치

> 엘라스틱 서치가 강력한 이유
- 오픈소스 검색엔진
- 전문 검색
- 통계 분석
- 스키마리스
- RESTful API
- 멀티테넌시(Multi-tenancy)
- Document-Oriented
- 역색인(Inverted Index)
- 확장성과 가용성

> 엘라스틱 서치의 약점
- '실시간'이 아닌점
- 트랜잭션과 롤백 기능을 제공하지 않는다.
- 데이터의 업데이트를 제공하지 않는다.
    

### 1.3 실습 환경 구축
> 엘라스틱 서치 설치
- 자바 설치
- 엘라스틱 서치 설치시 사용자 계정을 생성후 설치 권장
    ```json
    {
      "name": "b93c3535b922",
      "cluster_name": "docker-cluster",
      "cluster_uuid": "2Ql712GMTNyQBaVy0Upz9A",
      "version": {
        "number": "7.9.3",
        "build_flavor": "default",
        "build_type": "docker",
        "build_hash": "c4138e51121ef06a6404866cddc601906fe5c868",
        "build_date": "2020-10-16T10:36:16.141335Z",
        "build_snapshot": false,
        "lucene_version": "8.6.2",
        "minimum_wire_compatibility_version": "6.8.0",
        "minimum_index_compatibility_version": "6.0.0-beta1"
      },
      "tagline": "You Know, for Search"
    }
    ```

- 주요 설정 항목
  
    |속성명|설명|
    |:---|:---|
    |`cluster.name`|클러스터로 여러 노드를 하나로 묶기 위해 클러스터 명을 등록|
    |`node.master`|마스터 노드로 동작 여부를 지정|
    |`node.data`|데이터 노드로 동작 여부를 지정|
    |`node.name`|엘라스틱 서치 노드명을 설정, 미설정시 임의값을 설정|
    |`path.data`|엘라스틱 서치의 인덱스 경로를 지정, 미설정시 data 디렉토리에 인덱스 생성|
    |`path.logs`|엘라스틱 서치의 노드와 클러스터에서 생성되는 로그를 저장할 경로를 지정, 기본 경로는 `/path/to/logs`|
    |`path.repo`|엘라스틱서치 인덱스를 백업하기 위한 스냅샷의 경로를 지정|
    |`network.hosts`|특정 IP만 엘라스틱서치에 접근하도록 허용, 모든 IP 허용시 `0.0.0.0`, IP 값으로 `127.0.0.1`을 설정 시 개발 모드에서 프로덕트 모드로 자동 변경|
    |`http.port`|엘라스틱 서치 서버에 접근할 수 있는 HTTP API 호출을 위한 포트 번호 지정, 기본값은 `9200`|
    |`transport.tcp.port`|엘라스틱서치 클라이언트가 접근할 수 있는 TCP 포트, 기본값은 `9300`|
    |`discovery.zen.ping.unicast.hosts`|노트가 여러개인 경우 유니캐스트로 활성화된 다른 서버를 찾는다. 클러스터로 묶인 노드(서버)의 IP를 지정하면된다.|
    |`discovery.zen.minimum_master_nodes`|마스터 노드의 선출 기준이 되는 노드의 수를 지정|

> 키바나 설치
- 데이터 시각화 프로그램
- 엘라스틱 서치에 색인된 데이터를 검색하거나, 문서를 추가한다거나 삭제하는 등의 기능을 손쉽게 구현할 수 있다.
- Dev Tools 메뉴에서 문서와 매핑의 추가, 삭제 등의 작업을 JSON 포맷으로 엘라스틱서치에 요청할 수 있다.
- Kibana > Dev Tools > curl 요청 구조
    ```text
    GET _search
    {
        "query": {
            "match_all": {}
        }
    }
    ```
- `GET`: 요청 전달 방식 중 하나로 어떠한 변경 없이 쿼리에 대한 결과를 반환 받는 용도
- `_search`: 검색 쿼리를 의미, `_search` 앞 부분에 인덱스를 명시하여 해당 인덱스로만 범위를 한정해서 검색을 수행할 수도 있다.
    - 여기서는 어떠한 인덱스도 지정하지 않았기 때문에 전체 인덱스를 대상으로 검색이 수행된다.
    - size가 기본값 01으로 설정되어 있기 때문에 검색 결과로 10개의 문서만 반환하기 때문에 많은 양의 문서가 색인되어 있더라도 결과가 빠르게 반환된다.
    - curl 명령어에서는 -X 옵션 다음으로 지정했던 도메인 부분에 해당한다.
    - 키바나를 통해 전달되는 쿼리는 무조건 설정에 지정된 엘라스틱 서치로 전달되기 때문에 생략가능
  
- `{...}`: 쿼리 본문에 해당하며 모든 문서를 검색, curl 명령어에서는 -d 옵션에 해당

### 2 엘라스틱 서치 살펴보기

> 엘라스틱 서치를 구성하는 개념

분산 시스템을 지향하는 엘라스틱 서치의 전체적인 아키텍처에 대한 이해

- 기본 용어
    - 인덱스, 타입 문서, 필드로 구성
    - @인덱스
        - 데이터 저장 공간
        - 하나의 인덱스는 하나의 타입을 가지며, 하나의 물리적인 노드에 여러 개의 논리적인 인덱스를 생성할 수 있다.
        - 검색 시 인덱스 이름으로 문서를 검색, 여러 인덱스를 동시에 검색하는 것도 가능
        - 엘라스틱 서치를 분산환경으로 구성하는 경우, 하나의 인덱스가 여러 노드에 분산되어 저장되어 관리가 된다.
        - 엘라스틱 서치는 인덱스 생성 시 기본적으로 5개의 프라이머리 샤드와 1개의 레플리카 샤드 세트를 생성한다.
        - 인덱스 이름은 모두 소문자여야 하며 추가, 수정, 삭제, 검색은 RESTful API로 수행이 가능하다.
        - `만약 인덱스가 없는 상태에서 데이터가 추가된다면 데이터를 이용해 인덱스가 자동으로 생성된다.`
    - @샤드
        - 색인된 문서는 하나의 인덱스에 담긴다. 인덱스 내부에 색인된 데이터는 물리적인 공간에 여러 개의 파티션으로 나뉘어 구성되는데, 이 파티션을 엘라스틱 서치에서는 샤드라 부른다.
        - 엘라스틱 서치는 다수의 샤드로 문서를 분산 저장하고 있어 데이터 손실 위험을 최소화할 수 있다.
    - @타입
        - 타입(Type)은 인덱스의 논리적 구조를 의마하며, 인덱스 속성에 따라 분류하기도 한다.
        - 6.1 버전 부터는 인덱스당 하나의 타입만을 사용할 수 있다.
    - @문서
        - 문서는 엘라스틱 서치에서 데이터가 저장되는 최소 단위이다.
        - 기본적으로 JSON 포맷으로 데이터가 저장된다.
        - 데이터베이스와 비교하자면 테이블의 행이 엘라스틱 서치의 문서에 해당한다고 볼 수 있다.
        - 하나의 문서는 다수의 필드로 구성돼 있는데 각 필드는 데이터의 형태에 따라 용도에 맞는 데이터 타입(Data Type)을 정의해야 한다.
        - 또한 문서는 중첩 구조를 지원하기 때문에 이를 이용해 문서 안에 문서를 지정하는 것도 가능하다.
    - @필드
        - 필드는 문서를 구성하기 위한 속성
        - 일반적으로 데이터베이스의 컬럼과 비교할 수 있으나, 컬럼이 정적인 데이터 탕비인데 반해 필드는 좀 더 동적인 데이터 타입이라 할 수 있다.
        - 하나의 필드는 목적에 따라 다수의 데이터 타입을 가질 수 있다. 
          ex) 매칭 검색, 초성 검색을 지원할 수 있도록 2개의 데이터 타입을 정의하는 것이 가능
    - @매핑
        - 문서의 필드와 필드의 속성을 정의, 그에 따른 색인 방버븡 정의하는 프로세스
        - 인덱스의 매핑 정보에는 여러 가지 데이터 타입을 지정할 수 있지만 필드명은 중복해서 사용할 수 없다.

- 노드의 종류
    - @클러스터는 물리적인 노드 인스턴스들의 모임이라 할 수 있다.
    - 클러스터는 모든 노드의 검색과 색인 작업을 관장하는 논리적인 개념이라 할 수 있다.
    - 관계형 데이터베이스의 경우 모든 요청을 서버 하나에서 처리하여 결과를 제공하지만 엘라스틱 서치의 경우에는 다수의 서버로 분산해서 처리하는 것이 가능하여 대용량 데이터를 처리할 수 있다.
    - 분산 처리를 위해서는 다양한 형태의 노드들을 조합하여 클러스터를 구성해야 한다.
    - 기본적으로 마스터 노드가 전체적인 클러스터를 관리하고 데이터 노드가 실제 데이터를 관리한다.
    - 4가지 유형의 노드

        |노드명|용도|
        |:---|:---|
        |마스터노드(Master Node)|- 클러스터를 관리 <br/>- 노드 추가와 제거 같은 클러스터의 전반적인 관리를 담당한다.|
        |데이터 노드(Data Node)|- 실질적인 데이터를 저장한다. <br/>- 검색과 통계 같은 데이터 관련 작업을 수행한다.|
        |코디네이팅 노드(Coordinating Node)|- 사용자의 요청만 받아서 처리 <br/>- 클러스터 관련 요청은 마스터 노드에 전달하고 데이터 관련 요청은 데이터 노드에 전달한다.|
        |인제스트 노드(Ingest Node)|- 문서의 전처리 작업을 담당한다. <br/> - 인덱스 생성 전 문서의 형식을 다양하게 변경할 수 있다.|
        
        - 설정에 따라 각 노드는 한 가지 유형으로 동작할 수도 있고 여러 개의 유형을 겸해서 동작할 수 있다.
    
    - 마스터 노드(Master Node)
        - 인덱스를 생성, 삭제하는 등 클러스터와 관련된 전반적인 작업을 담당한다.
        - 위와 같은 역할을 수행하기 위해서 네트워크 속도가 빠르고 지연이 없는 노드를 마스터 노드로 선정해야 한다.
        - 다수의 노드를 마스터 노드로 성정할 수 있지만 결과적으로 하나의 노드만이 마스터 노드로 선출되어 동작한다.
        - 마스터 노드 전용으로 설정하는 방법
            - `conf/elasticsearch.yml`
            ```yaml
            node.master: true
            node.data: false
            node.ingest: false
            search.remote.connect: false
            ```
    - 데이터 노드(Data Node)
        - 데이터 노드는 문서가 실제로 저장되는 노드
        - 데이터가 실제로 분산 저장되는 물리적 공간인 샤드가 배치되는 노드
        - 색인 작업은 CPU, 메모리, 스토리지 같은 컴퓨팅 리소스를 많이 소모하기 때문에 리소스 모니터링을 필요로한다.
        - 데이터 노드는 가능한 마스터 노드와 분리해서 구성하는 것이 좋다.
        - 단 색인할 문서의 수가 적으면 함께 구성해도 상관은 없다.
        - 데이터 노드로 성정하는 방법
            - `conf/elasticsearch.yml`
            ```yaml
            node.master: false
            node.data: true
            node.ingest: false
            search.remote.connect: false
            ```
    - 코디네이팅 노드(Coordinating Node)
        - 데이터 노드, 마스터 노드, 인제스트 노드의 역할을 하지 않고, 들어온 요청을 단순히 라운드로빈 방식으로 분산시켜 주는 노드이다.
        - 코디네이팅 노드로 설정하는 방법
            - `conf/elasticsearch.yml`
            ```yaml
            node.master: false
            node.data: false
            node.ingest: false
            search.remote.connect: false
            ```
    - 인제스트 노드(Ingest Node)
        - 색인 전 데이터를 전처리 하기 위한 노드
        - 데이터의 포맷을 변경하기 위해 스크립트로 전처리 파이프라인을 구성하고 실행할 수 있다.
            - `conf/elasticsearch.yml`
            ```yaml
            node.master: false
            node.data: false
            node.ingest: true
            search.remote.connect: false
            ```

- 클러스터, 노드, 샤드
    - 클러스터와 노드의 관계 (하나의 클러스터에 노드1, 노드2로 구성되는 경우)
        - 엘라스틱 서치 클러스터는 인덱스의 문서를 조회할 때 마스터 노드를 통해 2개의 노드를 모두 조회하여 각 데이터를 취합한 후 결과를 하나로 합쳐 제공한다.
        - 현재는 하나의 클러스터로만 구성되어 있지만 여러 개의 클러스터를 연결하여 구성할 수도 있다.
            - 두 개 이상의 클러스터로 구성하는 경우 각 클러스터 명으로 구분되며 명시하지 않는 경우 임의 문자열로 지정된다.
        - `클러스터에 있는 노드는 실시간으로 추가, 제거가 가능하여 가용성, 확장성 측면에서 매우 유연하다.`
    - 클러스터의 동작 방식 이해 (하나의 클러스터에 3개의 노드로 구성되는 경우)
        - 프라미머리 샤드와 레플리카 샤드의 수를 조정하며 인덱스 생성 시 클러스터가 어떻게 동작하는지 분석
        - 프라이머리 샤드 3개, 레플리카 샤드 0개를 세트로 구성하는 경우
            ```json
            {
              "settings": {
                "index": {
                  "number_of_shards": 3,
                  "number_of_replicas": 0
                }
              }
            }
            ```
            - 샤드는 분산된 데이터에 따라 순차적인 번호를 가진다.
            - 일반적으로 프라이머리 샤드느 안정성을 위해 하나의 노드에 하나씩 분산된다.
            - 인덱스에 다수의 문서를 색인하게 되면 문서는 3개의 샤드 골고루 분산 저장한다.
              
        - 프라이머리 샤드 6개, 레플리카 샤드 0개를 세트로 구성하는 경우
            ```json
            {
              "settings": {
                "index": {
                  "number_of_shards": 6,
                  "number_of_replicas": 0
                }
              }
            }
            ```
            - 3개의 노드에 프라이머리 샤드 6개가 노드당 2개가 배치되며, 색인 시 6개의 샤드에 데이터가 분산된다.

        - 프라이머리 샤드 3개, 레플리카 샤드 1개 세트 구성
            - 레플리카 샤드는 프라이머리 샤드의 복제본이다.
            ```json
            {
              "settings": {
                "index": {
                  "number_of_shards": 3,
                  "number_of_replicas": 1
                }
              }
            }
            ```
            - 엘라스틱 서치는 장애 시 레플리카 샤드를 이용해 샤드를 복구한다.
            - 프라이머리 샤드와 레플리카 샤드가 서로 다른 노드에 배치된다.

        - 프라이머리 샤드 3개, 레플리카 샤드 3개 세트 구성
            - 레플리카 샤드는 프라이머리 샤드의 복제본이다.
            ```json
            {
              "settings": {
                "index": {
                  "number_of_shards": 3,
                  "number_of_replicas": 3
                }
              }
            }
            ```
            - 프라이머리 샤드의 복제본이 존재하기 때문에 물리적인 노드 하나가 죽더라도 나머지 노드 2개가 전체 데이터를 복구할 수 있다.
            - 장애가 발생하면 마스터 노트드는 데이터를 재분배하거나 레플리카 샤드를 프라이이머리 샤드로 승격시켜 서비스 중단 없는 복구가 가능해진다.
        - `장애극복(Failover) 상황을 염두에 두고 노드와 샤드의 수를 적절하게 구성해야 한다.`

> 엘라스틱서치에서 제공하는 주요 API
- 인덱스 관리 API
- 문서 관리 API
- 검색 API
- 집계 API

### 3 데이터 모델링
> 매핑 API 이해하기
- 매핑 인덱스 만들기
- 매핑 확인
- 매핑 파라미터
> 매타 필드
- `_index` 메타 필드
- `_type` 메타 필드
- `_id` 메타 필드
- `_uid` 메타 필드
- `_source` 메타 필드
- `_all` 메타 필드
- `_routing` 메타 필드
> 필드 데이터 타입
- Keyword 데이터 타입
- Text 데이터 타입
- Array 데이터 타입
- Numeric 데이터 타입
- Date 데이터 타입
- Range 데이터 타입
- Boolean 데이터 타입
- Geo-Point 데이터 타입
- IP 데이터 타입
- Object 데이터 타입
- Nested 데이터 타입
> 엘라스틱 서치 분석기
- 텍스트 분석 개요
- 역색인 구조
- 분석기의 구조
- 전처리 필터
- Tokenizer 필터
- Token 필터
- 동의어 사전
> Document API 이해하기
- 문서 파라미터
- Index API
- Get API
- Delete API
- Delete By Query API
- Update API
- Bulk API
- ReIndex API
