## 2.2 엘라스틱 서치에서 제공하는 주요 API
- 문서를 색인하기 위해서는 기본적으로 인덱스를 생성해야 한다.
- 인덱스를 통해 입력되는 문서의 필드를 정의하고, 각 필드에 알맞은 데이터 타입을 지정해야 한다.

### index vs indices
- index: 색인된 데이터
- indexing: 색인하는 과정
- indices: 매핑 정보를 저장하는 논리적인 데이터 공간

### 스키마리스
- 문서를 색인하기 위해서는 기본적으로 인덱스를 생성하는 과정이 필요한데, 인덱스를 생성하는 과정 없이 문서를 추가하더라도 문서가 색인되도록 지원하는 기능
- 최초 문서가 색인될 때 인덱스의 존재여부를 확인하고 인덱스가 존재하지 않는다면 문서를 분석해서 문서가 색인될 수 있도록 인덱스를 자동 생성하는 기능
- 이는 성능과 밀접한 연관이 있기 때문에 특수한 상황 및 데이터 구조와 검색방식을 확실히 이해하고 사용해야 한다.
- 인덱스를 자동 생성하는 경우 특정 단어를 검색할 때 검색 결과에서 누락되는 등 문제가 발생할 가능성이 높다.
- 기본적으로 모든 필드가 text 타입과 keyword 타입을 동시에 제공하는 멀티필드 기능으로 구성된다.
- 모든 필드가 text 타입 필드와 keyword 타입 필드를 동시에 필요로 하지않으므로 공간의 낭비를 초래한다.
- 이 경우 검색 품질이 떨어지거나 성능상 문제가 발생할 가능성이 커진다.
- 스키마리스를 이용해 색인한다면 기본적으로 text 타입의 Standard Analyzer를 사용하는 데이터 타입이 정의된다.
    - 이 경우 분석기가 문자열을 토큰으로 분리하여 Term이 생성되고 검색시 정확하게 matching 되는 키워드만 검색하게 될 것이다.
    - 원하는 결과를 얻기 위해서는 한글 형태소를 분석하는 분석기를 사용하도록 데이터 타입을 직접 정의해야 한다.
- 스키마리스 사용 중지 방법
    - 노드 설정 파일 수정
    - 자동 인덱스 생성 기능 비활성화
    ```yaml
    action.auto_create_index: false
    ```
    - 특정 컬럼의 자동 매핑 생성 비활성화
    ```yaml
    index.mapper.dynamic: false
    ```

### 인덱스 관리 API
- 인덱스의 추가, 삭제를 할 수 있다.
- 인덱스의 생성
    - 명령어
    ```shell
    PUT /{index명}
    {
      "settings" : {
        "number_of_shards" : 3,
        "number_of_replicas" : 2
      },
      "mappings" : {
        "_docs" : {
          "properties" : {
            "field1" : { "type" :  "integer" },
            "field2" : { "type" :  "text" },
            "field3" : { "type" :  "date" },
            "field4" : { "type" :  "keyword" }
          }
        }
      }       
    }
    ```
    - 매핑이라는 세부 설정을 이용
        - 매핑은 문서와 문서에 포함된 필드, 필드의 타입등을 세세하게 지정할 수 있다.
    - 한번 생성된 매핑 정보는 변경할 수 없다는 단점이 있다.
    - 잘못 생성하거나 변경을 하려는 경우, 데이터를 삭제하고 다시 색인해야 한다.
    - 단순히 문자열로 저장하고 싶은 경우 keyword 타입을 사용, `형태소 분석을 원하는 경우 text 타입`을 사용한다.
    - 코드 값과 연도는 숫자 데이터 타입과 날짜 타입으로 지정
    - 그외에 특별하지 않은 문자열은 keyword 타입으로 지정
- 인덱스의 삭제
    - 명령어
    ```shell
    DELETE /{index명}
    ```
    - 인덱스를 한 번 삭제하면 다시 복구할 수 없기 때문에 인덱스 삭제는 신중하게 해야 한다는 점이다.

### 문서 관리 API
- 문서의 추가 / 수정 / 삭제
- 문서의 ID를 기준으로 한 건의 문서를 다루는 Single document API
    - Index API: 한 건의 문서를 색인
    - Get API: 한 건의 문서를 조회
    - Delete API: 한 건의 문서를 삭제
    - Update API: 한 건의 문서를 업데이트
- 다수의 문서를 처리하는 Multi-document API
    - Multi Get API: 다수의 문서를 조회
    - Bulk API: 대량의 문서를 색인
    - Delete By Query API: 다수의 문서를 삭제
    - Update By Query API: 다수의 문서를 업데이트
    - Reindex API: 인덱스의 문서를 다시 색인
- 문서의 생성
    ```shell
    POST /{index명}/_doc/1
    ```
- 문서의 조회
    ```shell
    GET /{index명}/_doc/1
    ```
- 문서의 삭제
    ```shell
    DELETE /{index명}/_doc/1
    ```
- 문서의 생성에서 ID를 부여하지 않고 생성하는 경우의 문제점
    - 문서를 생성할 때 ID를 부여하지 않을 경우 UUID를 생성하여 자동으로 ID가 부여되나 해당 문서를 검색 및 업데이트를 하려는 경우 문제가 발생할 수 있다.
    - 검색엔진은 해당 데이터베이스와 주기적으로 동기화해야 하기 때문에 변경된 내용을 따라 동기화돼야 할 것이다.
    - 색인된 _id 값을 데이터베이스의 PK 혹은 식별이 되는 키 값과 매칭한 정보가 어딘가에는 저장되어 관리되어야 한다.
    - 대용량 데이터를 사용하는 경우 _id 값은 업데이트를 고려하여 데이터베이스 테이블의 식별 값과 맞춰 주는 것이 중요하다.

### 검색 API
- 문서 조회
- 엘라스틱 서치 검색 API의 사용방식 두 가지
    ```text
    1. HTTP URI(Uniform Resource Identifier) 형태의 파라미터를 URI에 추가해 검색하는 방법
    2. RESTful API 방식인 QueryDSL을 사용해 요청 본문(Request Body)에 질의 내용을 추가해 검색하는 방법
    ```
- Request Body 방식은 URI 방식보다 제약사항이 적기 때문에 Request Body 방식을 선호한다.
- URI 방식은 간단한 쿼리 검색을 하거나 디버깅할 때 간편하게 사용하는 경우에 종종 이용된다.
- 두 가지 표현식을 모두 사용하는 경우
    ```shell
    GET /{index명}/_doc/_search?q=필드명:검색키워드&pretty=true
    {
        "sort" : {
            "필드명" : {
                "order" : "asc"
            }
        }
    }
    ```
- QueryDSL을 사용하면 가독성이 높고, JSON 형식으로 다양한 표현이 가능해진다.
- Query의 조건을 여러 개 만들거나, 통계를 위한 집계(Aggregation) 쿼리 등 복잡한 쿼리를 작성하려면 QueryDSL을 사용하는 것이 좋다.
- URI 방식의 검색 질의
    - URI 방식의 검색 질의는 문서 ID인 _id 값을 사용해 문서를 조회하는 방식이다.
    ```shell
    GET /{index명}/_doc/docId?pretty=true
    ```
    - q 파라미터를 사용해 해당 용어와 일치하는 문서만 조회
        ```shell
        GET /{index명}/_search?q=장편
        ```
        - 검색 조건을 통해 조회하는 경우 _shards 에서 성공적으로 반환한 샤드의 수와 실패한 샤드의 수를 알 수 있다.
        - hits에서는 일치하는 문서의 수와 함께 점수(_score)가 가장 높은 상위 10개의 문서를 보여준다.
        - `검색에 실패한 샤드의 수는 검색 시 설정된 time_out에 따라 결정된다.`
        - `time_out 시간이 초과되면 그때까지 검색된 내용까지만 검색 결과로 반환한다.`
        - `따라서 실패한 샤드의 수가 지나치게 많다면 time_out 시간을 적절히 조정해야 한다.`

    - q 파라미터를 사용할 때 별도의 필드명을 지정하지 않으면 존재하는 모든 필드를 대상으로 검색을 수행한한다.
    - 특정 필드만 조회하고 싶다면 다음 코드와 같이 필드명을 포함해서 요청하면 된다.
        ```shell
        POST /인덱스명/_search?q=필드명:검색키워드
        ```
    - Request Body 방식의 검색 질의
        ```shell
        POST /{index명}/_search
        {
          JSON 구문
        }
        POST /{index명}/_search
        {
          "query" : {
            "term" : { "{field명}" : "{키워드}"}
          }
        }
        ```
    - 키의 종류
        ```shell
        {
          size: # 몇개의 결과를 반환할 지 결정한다. (기본 값은 10)
          from: # 어느 위치부터 반롼할 지 결정한다.
                # 0부터 시작하면 상위 10건의 데이터를 반환한다. (기본 값은 0)
          _source: # 특정 필드만 결과로 반환하고 싶을 때 사용한다.
          sort: # 특정 필드를 기준으로 정렬한다.
          query: {
            # 검색될 조건을 정의
          }
          filter: {
            # 검색 결과 중 특정한 값을 다시 보여준다.
            # 결과 내에서 재검색할 때 사용하는 기능 중 하나이다.
            # 다만 필터를 사용하게 되면 자동으로 source 값이 정렬되지 않는다.
          }
        }
        ```

### 집계 API
- 문서 통계
- 집계 API는 기본적으로 메모리 기반으로 동작하기 때문에 대용량의 데이터 통계 작업이 가능하다.
- 쿼리에 사용되는 집계에 따라 수치를 계산하고 동적으로 카운팅하거나 히스토그램 같은 작업 등도 할 수 있게 바뀌었다.
- 데이터 집계 (_search를 사용하여 집계, terms 키워드를 이용해 그룹화)
    ```shell
    POST /{index명}/_search?size=0
    {
      "aggs": {
        "{group명 정의}" : {
          "terms" : {
            "field": "{그룹화할 필드명}"
          }
        }
      }
    }
    ```
- 버킷 안에 다른 버킷의 결과를 추가하는 데이터 집계
    ```shell
    POST /{index명}/_search?size=0
    {
      "aggs": {
        "{group명 정의1}" : {
          "terms" : {
            "field": "{그룹화할 필드명}"
          },
          "aggs": {
            "{group명 정의2}" : {
              "terms" : {
                "field": "{그룹화할 필드명}"
              },
              
            }
          }
        }
      }
    }
    ```
- 데이터 집계 타입
    - 버킷 집계(Bucket Aggregation)
        - 집계 중 가장 많이 사용하는 방식
        - 문서의 `필드`를 기준으로 버킷을 집계
    - 메트릭 집계(Metric Aggregation)
        - 문서에서 추출된 값을 가지고 Sum, Max, Min, Avg를 계산
    - 매트릭스 집계(Matrix Aggregation)
        - 행렬의 값을 합하거나 곱한다.
    - 파이프라인 집계(Pipeline Aggregation)
        - 버킷에서 도출된 결과 문서를 다른 필드 값으로 재분류한다.
        - 즉, 다른 집계에 의해 생성된 출력 결과를 다시 한 번 집계한다.
